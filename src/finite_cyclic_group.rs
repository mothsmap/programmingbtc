use crate::field_element::FieldElement;
use crate::field_point::FieldPoint;
use num::{traits::Euclid, BigInt, FromPrimitive, Zero};
use std::str::FromStr;

// 有限循环群
#[derive(Debug, PartialEq, Clone)]
pub struct FiniteCyclicGroup {
    // y^2 = x^3 + ax + b
    pub a: BigInt,
    pub b: BigInt,
    // prime of the finite field
    pub p: BigInt,
    // generator point G
    pub g: FieldPoint,
    // the order of the group generated by G
    pub n: BigInt,
}

impl FiniteCyclicGroup {
    pub fn from_secp256k1() -> Self {
        // P = 2**256 - 2**32 - 977
        pub const P: &str =
            "115792089237316195423570985008687907853269984665640564039457584007908834671663";
        // N = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141
        pub const N: &str =
            "115792089237316195423570985008687907852837564279074904382605163141518161494337";
        // 原点
        pub const GX: &str =
            "55066263022277343669578718895168534326250603453777594175500187360389116729240";
        pub const GY: &str =
            "32670510020758816978083085130507043184471273380659243275938904335757337482424";
        let prime = BigInt::from_str(P).unwrap();
        let a = FieldElement::from_bigint(BigInt::zero(), prime.clone()).unwrap();
        let b = FieldElement::from_bigint(BigInt::from_i64(7).unwrap(), prime.clone()).unwrap();
        let gx = FieldElement::from_bigint(BigInt::from_str(GX).unwrap(), prime.clone()).unwrap();
        let gy = FieldElement::from_bigint(BigInt::from_str(GY).unwrap(), prime.clone()).unwrap();

        FiniteCyclicGroup {
            a: BigInt::zero(),
            b: BigInt::from_i64(7).unwrap(),
            p: prime,
            g: FieldPoint::from(Some(gx), Some(gy), a, b).unwrap(),
            n: BigInt::from_str(N).unwrap(),
        }
    }

    pub fn new(a: BigInt, b: BigInt, p: BigInt, x: BigInt, y: BigInt, n: BigInt) -> Self {
        // 生成点必须在曲线上
        if (&y).pow(2u32).rem_euclid(&p) != ((&x).pow(3u32) + &a * &x + &b).rem_euclid(&p) {
            panic!("生成点不在曲线上！");
        }

        let a2 = FieldElement::from_bigint(a.clone(), p.clone()).unwrap();
        let b2 = FieldElement::from_bigint(b.clone(), p.clone()).unwrap();

        let x2 = FieldElement::from_bigint(x, p.clone()).unwrap();
        let y2 = FieldElement::from_bigint(y, p.clone()).unwrap();

        FiniteCyclicGroup {
            a: a,
            b: b,
            p: p,
            g: FieldPoint::from(Some(x2), Some(y2), a2, b2).unwrap(),
            n: n,
        }
    }

    pub fn generate(&self, n: &BigInt) -> FieldPoint {
        let reduced_n = n.rem_euclid(&self.n);
        reduced_n * &self.g
    }

    pub fn generate_from_point(&self, n: &BigInt, x: &BigInt, y: &BigInt) -> FieldPoint {
        let reduced_n = n.rem_euclid(&self.n);
        let point = FieldPoint::from(
            Some(FieldElement::from_bigint(x.clone(), self.p.clone()).unwrap()),
            Some(FieldElement::from_bigint(y.clone(), self.p.clone()).unwrap()),
            FieldElement::from_bigint(self.a.clone(), self.p.clone()).unwrap(),
            FieldElement::from_bigint(self.b.clone(), self.p.clone()).unwrap(),
        )
        .unwrap();
        reduced_n * point
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::utils::Hex;
    use num::{traits::Euclid, FromPrimitive};

    #[test]
    pub fn test_secp256k1_parameters() {
        // generator point on curve, or crash
        let group = FiniteCyclicGroup::from_secp256k1();

        let last_pt = group.generate(&group.n);
        assert!(last_pt.is_infinity());
    }

    #[test]
    pub fn test_zero_prove_concept() {
        // 0知识证明的核心在于求解下面这个离散对数问题：
        // uG + vP = kG
        // 只有知道私钥e的人才能让等式左边等于右边(因为P = eG)
        // 通过把签名的原因(z)和签名的目标(r)嵌入到左边，隐含着手握私钥的人出于原因z，完成了目标r
        // 因此构造:
        // u = z/s; v = r/s

        let group = FiniteCyclicGroup::from_secp256k1();
        let z = "0xbc62d4b80d9e36da29c16c5d4d9f11731f36052c72401a76c23c0fb5a9b74423";
        let big_z = BigInt::from_hex(&z[2..]);
        let r = "0x37206a0610995c58074999cb9767b87af4c4978db68c06e8e6e81d282047a7c6";
        let big_r = BigInt::from_hex(&r[2..]);
        let s = "0x8ca63759c1157ebeaec0d03cecca119fc9a75bf8e6d0fa65c841c8e2738cdaec";
        let big_s = BigInt::from_hex(&s[2..]);
        let px = "0x04519fac3d910ca7e7138f7013706f619fa8f033e6ec6e09370ea38cee6a7574";
        let py = "0x82b51eab8c27c66e26c858a079bcdf4f1ada34cec420cafc7eac1a42216fb6c4";

        // s^-1
        let s_inv = big_s.modpow(&(&group.n.clone() - 2), &group.n.clone());
        // u = z/s
        let u = (&big_z * &s_inv).rem_euclid(&group.n);
        // v = r/s
        let v = (&big_r * &s_inv).rem_euclid(&group.n);

        // uG + vP = kG
        let ug = group.generate(&u);
        let vp =
            group.generate_from_point(&v, &BigInt::from_hex(&px[2..]), &BigInt::from_hex(&py[2..]));
        let r_shot = (ug + vp).x.unwrap().num;
        assert!(r_shot == big_r);
    }
}
